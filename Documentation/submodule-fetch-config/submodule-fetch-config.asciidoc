About reading and applying configuration of non-checked out revisions during fetch
==================================================================================


General
-------

How do we solve conflicting configurations from .gitmodules in commits?
 . We do it the simple way, warn, do nothing and currently rely on the
   user to solve them.
 . Later once some more experience is gained we might solve some
   constellations automatically.

What is the configuration file precedence?
 . see Configuration

Configuration possibilities for recursive submodule fetch
 . fetch.recurseSubmodules (config only)
 . submodule."name".fetchRecurseSubmodules (.gitmodules / config)

User Stories
------------

----
$ git clone --recurse-submodules your-cool-project
----

Whether git will fetch or clone a submodule depends on the value of
'submodule.recursesubmodules' or 'submodule.autoinit' configuration
and their submodule specific configuration. If fetch or clone are given
the --recurse-submodules option the autoinit configuration is assumed to
be true.


Submodule Recursion Checked Out
-------------------------------

I expect all initialized submodules to behave after the local or checked
out configuration (.git/config and .gitmodules).

Let's say we have configured 'submodule.recursesubmodules = on' or given
the '--recurse-submodules[=on]' commandline option to fetch.

Superproject has a linear history:

. I would expect "git fetch" to run fetch in all submodules checked out
  in the worktree

. I wouldn't expect it to run fetch in old submodules not
  checked out in the worktree, but I wouldn't mind if it did
  either.

. I would expect "git fetch" to clone any new submodules that I would
  need to "git merge --recurse-submodules FETCH_HEAD", and any
  submodules needed for intermediate states.

Superproject has multiple branches:

. Same as before, but I'd expect it to clone or fetch new and
  existing submodules for <existing tip>..<new tip> of all branches.


Submodule Recursion On-Demand (local config)
--------------------------------------------
Let's say 'submodule.recursesubmodules = on-demand' or given the
'--recurse-submodules=on-demand' commandline option to fetch.

Superproject has a linear history:

. Same as with '--recurse-submodules=on' but I would only expect fetch
  to fetch or clone submodules that have changed/are new in the commits
  fetched

Superproject hast multiple branches:

. Similar to before but also fetch changed/new submodules between
  <existing tip>..<new tip> of all branches.


Submodule Recursion Off (local config)
--------------------------------------
Let's say 'submodule.recursesubmodules = off' or commandline option
'--recurse-submodules=off' or no config or option.

No submodules will be fetched


Submodule Recursion Not Checked Out
------------------------------------
Let's say the submodule is not in the current index (checked out) and
the .gitmodules in all fetched commits agree on submodule <name>'s config
'submodule.<name>.recursesubmodules = on'

. I would the submodule to be fetched/cloned when the recorded
  submodule-commit was changed in any commit between <existing
  tip>..<new tip>.

. I would not expect the submodule to be fetched/cloned if there was no
  change of the recorded submodule-commit in the fetched commits but I
  would not mind if it was either.

The same applies to 'submodule.<name>.recursesubmodules = on-demand'
except that I would mind if a submodule was fetched which had no change
in the recorded submodule-commit.

Let's assume the same situation as before but the configurations of
'submodule.<name>.recursesubmodules' in .gitmodules of the fetched
commits disagree.

. I would expect git to warn me that the configuration of submodule
  <name> was not the same across all fetched commits.

- I would expect git to skip the recursive fetch of those submodules and
  tell me what I can do to solve this.



Let's say +submodule.recursesubmodules = off+
 or --recurse-submodules=off commandline option.

. I would expect "git fetch" to skip all submodules by default
  except the ones configured otherwise

Plan
----

In superproject

. Lookup all changed submodule names (changed_submodules) received during fetch
  During collection phase: For each revision that changes a submodule
  store:
	.. .gitmodules sha1 (for subsequent readings of the same config)
	.. path
	.. name

. For each submodule in the index that is in changed_submodules
	.. Lookup its name from repository config and .gitmodules
	.. Fetch depending on local and checked out configuration
	.. Add submodule to fetched_submodules
	.. Remove submodule from changed_submodules

. For each changed submodule left in list from 1.
	.. Skip and warn if not all found configurations are the same
	   and no local config for that module
	.. Fetch or clone depending on local configuration or if that
	   does not exist from revisions
	.. Add submodule to fetched_submodules

. For each submodule in .git/modules
	.. Skip if in fetched_submodules
	.. fetch depending on local configuration (e.g. in .git/config)
	   or commandline

. If we were given the special option --recurse-submodules=all it
  overrides all revisions, checked out or local recurseSubmodules
  configurations
	.. Parse all commits .gitmodules
	.. Try to fetch or clone all found module names

.gitmodules and local config
----------------------------
All configuration values for submodules in .git/modules/ like
recurseSubmodules, autoinit, ... come from local config or commandline.

If there is a submodule described in some revisions .gitmodules
and we come to the conclusion that it should be fetched. The
fetch automatically clones it into .git/modules and copies
the url from .gitmodules into .git/config

If .gitmodules configuration values disagree between revisions we
fallback on the configured global default. E.g.
+submodule.recursesubmodules+ or the --recurseSubmodules commandline
option. If nothing is configured the current default will be do not do
anything.

We only use .gitmodules values from commits if they are consistent
through all parsed commits.

If .gitmodules values conflict we do nothing and warn the user.


For expensive operations we might have a different command: +submodule fetch-all+

If the submodule urls disagree and I do not have a local configuration I
stop. The consolidated configuration list of gitmodules needs a
conflicting configuration marker. The fallback is to do no fetch and
tell the user possibilities how to proceed.
e.g.:
----
	git checkout origin/master
	git submodule sync
	git submodule update --init --recursive
----

Configuration (the latter overrides the earlier)
------------------------------------------------

 1. General config (fetch.RecurseSubmodules)
 2. Command line default (--recurse-submodules-default)
 3. consolidated .gitmodules from each commit
    (submodule."name".fetchRecurseSubmodules)
 4. Per submodule config (system, user, repo)
    (submodule."name".fetchRecurseSubmodules)
 5. Command line option (--recurse-submodules)


Roadmap
-------
Current state: fetching of initialized submodules, but the .gitmodules
config is still taken from the work tree.

Next steps:

. Fetch renamed initialized submodules using the path to name mapping of
  the +.gitmodules+ file of the correct commit.
. Make fetch use the consolidated +.gitmodules+ configuration from all
  fetched commits.
. Implement +autoinit+ config cloning the bare submodule repo into
  +.git/modules+ and initializing them by putting the consolidated URL
  into +.git/config+.
